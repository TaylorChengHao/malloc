<!--
 * @Author: your name
 * @Date: 2020-11-16 12:27:46
 * @LastEditTime: 2020-11-16 14:06:21
 * @LastEditors: Please set LastEditors
 * @Description: In User Settings Edit
 * @FilePath: \git_proj\malloc\README.md
-->
# 一个自己实现的malloc
最简单的堆的方案就是连续的内存数组，每次分配都直接指针后移取一段空间，那么吞吐量是最优的，但是这种的内存利用率极低。要在吞吐量和堆利用率之间平衡。
这里根据csapp第三版中的9.9.12 实现一个简单的分配器
基于隐式空闲链表，一段连续的内存空间，有点类似数组，但是其中分成了不同大小的堆块。堆块是双字对齐的、头尾分别有一个字的标记（储存堆块的大小和此堆块是否被使用了的信息），形成了类似数组的结构。
堆分配器寻找合适堆块的策略有3种，首次适配，下一次适配，最佳适配。我这里使用了首次适配，最简单那种，顺序遍历链表，找到一个适配的堆块就立即使用。
处理空闲块合并的策略是立即边际合并，每一次扩展堆和释放堆块后就马上边际合并。
最大块2^32=4GB,代码是64位干净的，不用修改就可以运行在32位和64位的gcc上面
memlib.c提供一个内存系统模型，使我们能在不干涉系统malloc的情况下，运行分配器。
本分配器的使用要在代码中先初始化memlib提供的内存系统模型（mem_init），然后还要初始化分配器（mm_init），如要替换系统的malloc，要改变源码的硬编码。本来想利用类似运行时打桩的机制，不侵入式地使用这个malloc，这样一来就不行了。不过考虑到打桩机制本意更多是可以监控程序的函数调用吧，大型服务端很多本来都是要集中管理malloc，必然会带一个自己的malloc实现，故不必再通过打桩的方式了。
```sh
gcc memlib.c mm.c test.c -o test
./test
```
